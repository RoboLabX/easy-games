<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Roblox Tetris</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: linear-gradient(135deg, #ff4747, #000000);
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    .container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: center;
      gap: 10px;
      width: 100%;
      max-width: 600px;
    }
    canvas {
      background: black;
      display: block;
    }
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .box {
      background: #222;
      color: white;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      font-size: 14px;
    }
    .hints {
      margin-top: 10px;
      color: white;
      font-size: 12px;
      text-align: center;
    }
    @media (max-width: 600px) {
      .container {
        flex-direction: row;
        align-items: flex-start;
      }
      .sidebar {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="board" width="240" height="400"></canvas>
    <div class="sidebar">
      <div class="box">
        <p>Score</p>
        <p id="score">0</p>
      </div>
      <div class="box">
        <p>Next</p>
        <canvas id="next" width="80" height="80"></canvas>
      </div>
    </div>
  </div>
  <div class="hints">
    <p>Controls: ⬅️ ➡️ move | ⬆️ rotate | ⬇️ drop</p>
    <p>Mobile: swipe left/right = move | tap = rotate | hold = drop</p>
  </div>
  <script>
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const nextCanvas = document.getElementById("next");
    const nextCtx = nextCanvas.getContext("2d");

    const ROWS = 20, COLS = 10, BLOCK = 20;
    canvas.width = COLS * BLOCK;
    canvas.height = ROWS * BLOCK;

    const COLORS = {
      I: "#00FFFF",
      J: "#0000FF",
      L: "#FFA500",
      O: "#FFFF00",
      S: "#00FF00",
      T: "#800080",
      Z: "#FF0000"
    };

    const SHAPES = {
      I: [[1,1,1,1]],
      J: [[1,0,0],[1,1,1]],
      L: [[0,0,1],[1,1,1]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0]],
      T: [[0,1,0],[1,1,1]],
      Z: [[1,1,0],[0,1,1]]
    };

    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(""));
    let score = 0;
    let current, next;

    function drawBlock(x, y, color, context=ctx) {
      context.fillStyle = color;
      context.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
      context.strokeStyle = "#111";
      context.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) drawBlock(x, y, board[y][x]);
          else {
            ctx.strokeStyle = "#333";
            ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
          }
        }
      }
      drawPiece(current);
    }

    function randomPiece() {
      const keys = Object.keys(SHAPES);
      const type = keys[Math.floor(Math.random() * keys.length)];
      return {
        piece: SHAPES[type],
        color: COLORS[type],
        x: Math.floor(COLS/2) - 1,
        y: 0
      };
    }

    function drawPiece(p, context=ctx) {
      p.piece.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) drawBlock(p.x + dx, p.y + dy, p.color, context);
        });
      });
    }

    function collide(piece, x, y) {
      return piece.some((row, dy) =>
        row.some((val, dx) =>
          val && (
            x + dx < 0 || x + dx >= COLS || y + dy >= ROWS || board[y+dy]?.[x+dx]
          )
        )
      );
    }

    function merge() {
      current.piece.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) board[current.y + dy][current.x + dx] = current.color;
        });
      });
    }

    function clearLines() {
      let cleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell)) {
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(""));
          cleared++;
          y++;
        }
      }
      if (cleared > 0) {
        score += cleared * 100;
        document.getElementById("score").textContent = score;
      }
    }

    function drop() {
      if (!collide(current.piece, current.x, current.y + 1)) {
        current.y++;
      } else {
        merge();
        clearLines();
        current = next;
        next = randomPiece();
        if (collide(current.piece, current.x, current.y)) {
          alert("Game Over! Final Score: " + score);
          board = Array.from({ length: ROWS }, () => Array(COLS).fill(""));
          score = 0;
          document.getElementById("score").textContent = score;
          current = randomPiece();
          next = randomPiece();
        }
      }
    }

    function rotatePiece(){
      const rotated = current.piece[0].map((_,i) => current.piece.map(r => r[i])).reverse();
      let testX = current.x;
      if(!collide(rotated, testX, current.y)){
        current.piece = rotated;
        return;
      }
      for (let offset of [-1, 1, -2, 2]) {
        if(!collide(rotated, testX + offset, current.y)){
          current.x += offset;
          current.piece = rotated;
          return;
        }
      }
    }

    document.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft" && !collide(current.piece, current.x - 1, current.y)) current.x--;
      if (e.key === "ArrowRight" && !collide(current.piece, current.x + 1, current.y)) current.x++;
      if (e.key === "ArrowDown") drop();
      if (e.key === "ArrowUp") rotatePiece();
      drawBoard();
    });

    // Mobile controls
    let touchStartX = 0, touchStartY = 0, holdTimer;
    canvas.addEventListener("touchstart", e => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      holdTimer = setTimeout(() => { drop(); drawBoard(); }, 500);
    });
    canvas.addEventListener("touchend", e => {
      clearTimeout(holdTimer);
    });
    canvas.addEventListener("touchmove", e => {
      const touch = e.touches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30) { current.x++; }
        if (dx < -30) { current.x--; }
      } else {
        if (dy > 30) { drop(); }
      }
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      drawBoard();
    });
    canvas.addEventListener("click", () => { rotatePiece(); drawBoard(); });

    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      drawPiece({...next, x: 1, y: 1}, nextCtx);
    }

    function update() {
      drop();
      drawBoard();
      drawNext();
    }

    current = randomPiece();
    next = randomPiece();
    setInterval(update, 500);
  </script>
</body>
</html>
