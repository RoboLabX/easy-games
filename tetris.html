<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Roblox Style Tetris1</title>
<style>
  body {
    background-color: #1e1e2e;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  .container {
    display: flex;
    flex-direction: row;
    gap: 15px;
    align-items: flex-start;
  }
  canvas {
    background-color: #111;
    border: 4px solid #00ff90;
    border-radius: 10px;
    display: block;
  }
  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  .panel {
    background-color: #2a2a3d;
    border: 3px solid #00ff90;
    border-radius: 10px;
    padding: 10px;
    text-align: center;
    min-width: 100px;
  }
  .hint {
    margin-top: 10px;
    font-size: 14px;
    color: #aaa;
  }
  @media (max-width: 768px) {
    .container {
      flex-direction: column;
      align-items: center;
    }
    .side-panel {
      flex-direction: row;
      justify-content: center;
      gap: 10px;
    }
  }
</style>
</head>
<body>
<div class="container">
  <canvas id="tetris" width="240" height="400"></canvas>
  <div class="side-panel">
    <div class="panel">
      <h3>Score</h3>
      <div id="score">0</div>
    </div>
    <div class="panel">
      <h3>Next</h3>
      <canvas id="next" width="80" height="80"></canvas>
    </div>
  </div>
</div>
<div class="hint">
  Controls: Arrow keys ← → ↓ to move, ↑ to rotate, Space = drop.<br>
  Mobile: Swipe = move, Tap = rotate, Hold = soft drop.
</div>

<script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
context.scale(20, 20);

const nextCanvas = document.getElementById('next');
const nextCtx = nextCanvas.getContext('2d');
nextCtx.scale(20, 20);

const matrix = Array.from({length:20}, () => Array(12).fill(0));
let current, nextPiece;
let score = 0;

const colors = [
  null,
  '#00f0f0', '#0000f0', '#f0a000',
  '#f0f000', '#00f000', '#a000f0', '#f00000'
];

function createPiece(type){
  switch(type){
    case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
    case 'O': return [[2,2],[2,2]];
    case 'L': return [[0,3,0],[0,3,0],[0,3,3]];
    case 'J': return [[0,4,0],[0,4,0],[4,4,0]];
    case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
    case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
    case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
  }
}

function drawMatrix(matrix, offset, ctx){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        ctx.fillStyle = colors[value];
        ctx.fillRect(x+offset.x,y+offset.y,1,1);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(x+offset.x,y+offset.y,1,1);
      }
    });
  });
}

function collide(piece, posY, posX){
  const m = piece, o = {x:posY, y:posX};
  for(let y=0;y<m.length;++y){
    for(let x=0;x<m[y].length;++x){
      if(m[y][x] && (matrix[y+o.y] && matrix[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(piece){
  piece.piece.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        matrix[y+piece.y][x+piece.x] = value;
      }
    });
  });
}

function playerReset(){
  const pieces = 'TJLOSZI';
  current = {
    piece: createPiece(pieces[Math.floor(Math.random()*pieces.length)]),
    x: 4,
    y: 0
  };
  if(nextPiece){
    current.piece = nextPiece;
  }
  nextPiece = createPiece(pieces[Math.floor(Math.random()*pieces.length)]);
  if(collide(current.piece,current.x,current.y)){
    // Game Over
    matrix.forEach(row=>row.fill(0));
    score = 0;
    document.getElementById('score').innerText = score;
  }
  drawNext();
}

function drawNext(){
  nextCtx.fillStyle = "#2a2a3d";
  nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  drawMatrix(nextPiece, {x:1,y:1}, nextCtx);
}

function rotatePiece(){
  const rotated = current.piece[0].map((_,i)=>current.piece.map(r=>r[i])).reverse();

  let testX = current.x;

  if(!collide(rotated,testX,current.y)){
    current.piece = rotated;
    return;
  }

  // Wall kicks
  for(let offset of [-1,1,-2,2]){
    if(!collide(rotated,testX+offset,current.y)){
      current.x += offset;
      current.piece = rotated;
      return;
    }
  }
}

function drop(){
  current.y++;
  if(collide(current.piece,current.x,current.y)){
    current.y--;
    merge(current);
    sweep();
    playerReset();
  }
}

function move(offset){
  current.x += offset;
  if(collide(current.piece,current.x,current.y)){
    current.x -= offset;
  }
}

function softDrop(){
  drop();
}

function sweep(){
  let rowCount=1;
  outer: for(let y=matrix.length-1;y>=0;--y){
    for(let x=0;x<matrix[y].length;++x){
      if(matrix[y][x]===0){
        continue outer;
      }
    }
    const row = matrix.splice(y,1)[0].fill(0);
    matrix.unshift(row);
    y++;
    score += rowCount*10;
    rowCount*=2;
  }
  document.getElementById('score').innerText = score;
}

function draw(){
  context.fillStyle = "#000";
  context.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(matrix,{x:0,y:0},context);
  drawMatrix(current.piece,{x:current.x,y:current.y},context);
}

let dropCounter=0;
let dropInterval=1000;
let lastTime=0;

function update(time=0){
  const delta=time-lastTime;
  lastTime=time;
  dropCounter+=delta;
  if(dropCounter>dropInterval){
    drop();
    dropCounter=0;
  }
  draw();
  requestAnimationFrame(update);
}

// Controls
document.addEventListener('keydown',event=>{
  if(event.keyCode===37){move(-1);}
  else if(event.keyCode===39){move(1);}
  else if(event.keyCode===40){softDrop();}
  else if(event.keyCode===38){rotatePiece();}
  else if(event.keyCode===32){while(!collide(current.piece,current.x,current.y+1)){current.y++;}}
});

// Touch Controls
let touchStartX=null, touchStartY=null, touchStartTime=null;
canvas.addEventListener('touchstart',e=>{
  const touch=e.touches[0];
  touchStartX=touch.clientX;
  touchStartY=touch.clientY;
  touchStartTime=Date.now();
});
canvas.addEventListener('touchend',e=>{
  const touch=e.changedTouches[0];
  const dx=touch.clientX-touchStartX;
  const dy=touch.clientY-touchStartY;
  const dt=Date.now()-touchStartTime;
  
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>30) move(1);
    else if(dx<-30) move(-1);
  }else{
    if(dy>30){ // down swipe
      softDrop();
    }
  }
  if(Math.abs(dx)<10 && Math.abs(dy)<10){
    if(dt>300){ // tap+hold
      softDrop();
    } else {
      rotatePiece(); // quick tap
    }
  }
});

// Start
playerReset();
update();
</script>
</body>
</html>
